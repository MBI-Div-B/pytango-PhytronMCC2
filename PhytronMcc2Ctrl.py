#!/usr/bin/python -u
# coding: utf8

#   "$Name:  $";
#   "$Header: /storage00/tango/CVS/PhytronMcc2CtrlDs/src/PhytronMcc2Ctrl.py,v 1.2 2007/07/09 09:44:03 jribas Exp $";
#=============================================================================
#
# file :        PhytronMcc2Ctrl.py
#
# description : Python source for the PhytronMcc2Ctrl and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PhytronMcc2Ctrl are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author: Dirk Rohloff $
#
# $Revision:  $
#
#=============================================================================
#       This file is generated by POGO
#   (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================

import time
import PyTango
import sys
import serial
import array
from PyTango.server import Device, DeviceMeta, device_property, class_property

flagDebugIO = 1


class PhytronMcc2Ctrl(PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------
    PARITIES = ["none", "odd" , "even"]
    FLOWCONTROL = ["none" , "software", "hardware", "sw/hw"]
    TERMINATOR = ["LF/CR", "CR/LF", "CR", "LF", "NONE"]
    TERMINATORCHAR = ["\n\r", "\r\n", "\r", "\n", ""]


    def __init__(self, cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)        
        self.info_stream("In %s::__init__()" % self.get_name())
        PhytronMcc2Ctrl.init_device(self)


    def delete_device(self):
        self.info_stream("[Device delete_device method] for device %s" % self.get_name())


    def init_device(self):
        self.info_stream("In %s::init_device()" % self.get_name())
        self.set_state(PyTango.DevState.OFF)
        self.get_device_properties(self.get_device_class())
        
        self.configure = True
        self.serial = serial.Serial()
        
        self.serial.baudrate = self.baudrate
        self.serial.port = self.port
        
        if flagDebugIO:
            print("PhytronMcc2Ctrl.init_device: port is %s " % self.port)
            print("PhytronMcc2Ctrl.init_device: baudrate is %s " % self.baudrate)
            
        self.bytesize = 8
        self.serial.bytesize = self.bytesize
        
        self.parity = PhytronMcc2Ctrl.PARITIES[0]
        self.current_parity = self.parity
        self.serial.parity = serial.PARITY_NONE

        self.stopbits = 1
        self.serial.stopbits = self.stopbits

        self.timeout = 0
        self.serial.timeout = self.timeout
        
        self.flowcontrol = PhytronMcc2Ctrl.FLOWCONTROL[0]
        self.current_flowcontrol = self.flowcontrol
        self.serial.xonxoff = 0
        self.serial.rtscts = 0

        self.terminator = PhytronMcc2Ctrl.TERMINATOR[0]
        self.terminatorchar = chr(3)    # end of text PhytronMcc2Ctrl.TERMINATORCHAR[0]
        
        # open serial port
        self.open()


    def always_executed_hook(self):
        self.info_stream("In %s::always_excuted_hook()" % self.get_name())


    def open(self):
        self.info_stream("In %s::open()" % self.get_name())
        #   Add your own code here

        # configure port
        if self.configure:
            self.serial.baudrate = self.baudrate
            self.serial.port = self.port
            self.serial.bytesize = self.bytesize
            self.serial.stopbits = self.stopbits

            self.serial.timeout = self.timeout
            self.current_flowcontrol = self.flowcontrol

            if self.current_flowcontrol == "none":
                self.serial.xonxoff = 0
                self.serial.rtscts = 0
            elif self.current_flowcontrol == "software":
                self.serial.xonxoff = 1
                self.serial.rtscts = 0
            elif self.current_flowcontrol == "hardware":
                self.serial.xonxoff = 0
                self.serial.rtscts = 1
            elif self.current_flowcontrol == "sw/hw":
                self.serial.xonxoff = 1
                self.serial.rtscts = 1

            self.current_parity = self.parity               
            if self.current_parity == PhytronMcc2Ctrl.PARITIES[0]:
                self.serial.parity = serial.PARITY_NONE
            elif self.current_parity == PhytronMcc2Ctrl.PARITIES[1]:
                self.serial.parity = serial.PARITY_ODD
            elif self.current_parity == PhytronMcc2Ctrl.PARITIES[1]:
                self.serial.parity = serial.PARITY_EVEN

        try:
            self.serial.open()
            self.set_state(PyTango.DevState.ON)
            self.configure = False
        except:
            print("PhytronMcc2Ctrl.open: failed to open %s " % self.port)
            sys.exit(255)
        
        if flagDebugIO:
            print("PhytronMcc2Ctrl.open: connected to %s " % self.port)


    def is_open_allowed(self):
        if self.get_state() in [PyTango.DevState.ON,
                                PyTango.DevState.FAULT]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def close(self):
        self.info_stream("In %s::close()" % self.get_name())
        #   Add your own code here
        try:
            self.serial.close()
            self.set_state(PyTango.DevState.OFF)
        except:
            pass


    def is_close_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def flush_input(self):
        self.info_stream("In %s::flush_input()" % self.get_name())
        #   Add your own code here
        try:
            self.serial.flush_input()
        except:
            pass


    def is_flush_input_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def flush_output(self):
        self.info_stream("In %s::flush_output()" % self.get_name())
        #   Add your own code here
        try:
            self.serial.flush_output()
        except:
            pass


    def is_flush_output_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def write_read(self, cmd):
        self.serial.write(cmd.encode())
        self.serial.flush()
        # 20ms Warten
        time.sleep(0.02)    
        argout =  []
        s=''
        s = self.serial.readline()
        self.debug_stream(s)
        b = array.array('B', s)
        argout = b.tolist()
        return argout
        
    
    def write(self, cmd):
        self.info_stream("In %s::write()" % self.get_name())
        self.serial.write(cmd.encode())
        

    def is_write_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True
    
    
    def read(self, argin):
        self.info_stream("In %s::read()" % self.get_name())
        #   Add your own code here
        argout =  []
        s = self.serial.read(argin)
        self.debug_stream(s)
        b = array.array('B', s)
        argout = b.tolist()
        return argout


    def is_read_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def read_line(self):
        self.info_stream("In %s::read_line()" % self.get_name())
        #   Add your own code here
        argout =  []
        s = self.serial.readline(eol=self.terminatorchar)
        self.debug_stream(s)
        b = array.array('B', s)
        argout = b.tolist()
        return argout


    def is_read_line_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True
        

    def read_until(self,c):
        self.info_stream("In %s::read_until()" % self.get_name())
        #   Add your own code here
        argout =  []
        s = self.serial.read_until(c)
        self.debug_stream(s)
        b = array.array('B', s)
        argout = b.tolist()
        return argout


    def is_read_until_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


class PhytronMcc2CtrlClass(PyTango.DeviceClass):

    #   Class Properties
    class_property_list = {
        }

    #   Device Properties
    device_property_list = {
        'port':
            [PyTango.DevString,
            "COM Port of the device",
            ["none"] ],
        'baudrate':
            [PyTango.DevULong,
            "Baudrate of the COM port",
            [0]],

        }

    #   Command definitions
    cmd_list = {
        'open':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'close':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'flush_input':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'flush_output':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'write':
            [[PyTango.DevString, ""],
            [PyTango.DevVoid, ""]],
        'read':
            [[PyTango.DevUShort, "Characters to read"],
            [PyTango.DevVarCharArray, "Characters readed"]],
        'read_line':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVarCharArray, "Characters readed"]],
        'write_read':
            [[PyTango.DevString, ""],
            [PyTango.DevVarCharArray, "Characters readed"]],
        'read_until':
            [[PyTango.DevUChar, "end char"],
            [PyTango.DevVarCharArray, "Characters readed"]],            
        }


    #   Attribute definitions
    attr_list = {
        }


def main(*args):
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(PhytronMcc2CtrlClass, PhytronMcc2Ctrl,'PhytronMcc2Ctrl')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()
    except PyTango.DevFailed, e:
        print '-------> Received a DevFailed exception:',e
    except Exception, e:
        pass


if __name__ == '__main__':
    main()
