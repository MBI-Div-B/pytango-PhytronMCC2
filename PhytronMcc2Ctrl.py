#!/usr/bin/python -u
# coding: utf8

#   "$Name:  $";
#   "$Header: /storage00/tango/CVS/PhytronMcc2CtrlDs/src/PhytronMcc2Ctrl.py,v 1.2 2007/07/09 09:44:03 jribas Exp $";
#=============================================================================
#
# file :        PhytronMcc2Ctrl.py
#
# description : Python source for the PhytronMcc2Ctrl and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PhytronMcc2Ctrl are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author: Dirk Rohloff $
#
# $Revision:  $
#
#=============================================================================
#       This file is generated by POGO
#   (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#

import time
import PyTango
import sys
import serial
import array
from PyTango.server import Device, DeviceMeta, device_property, class_property

flagDebugIO = 1

#==================================================================
#   PhytronMcc2Ctrl Class Description:
#
#         Python Serial Line device server for  windows and linux
#
#==================================================================
#   Device States Description:
#
#   DevState.ON :     Serial Port Open
#   DevState.FAULT :
#   DevState.OFF :
#==================================================================


class PhytronMcc2Ctrl(PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------
    PARITIES = ["none", "odd" , "even"]
    FLOWCONTROL = ["none" , "software", "hardware", "sw/hw"]
    TERMINATOR = ["LF/CR", "CR/LF", "CR", "LF", "NONE"]
    TERMINATORCHAR = ["\n\r", "\r\n", "\r", "\n", ""]

#------------------------------------------------------------------
#   Device constructor
#------------------------------------------------------------------
    def __init__(self, cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)        
        self.info_stream("In %s::__init__()" % self.get_name())
        PhytronMcc2Ctrl.init_device(self)

#------------------------------------------------------------------
#   Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.info_stream("[Device delete_device method] for device %s" % self.get_name())

#------------------------------------------------------------------
#   Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.info_stream("In %s::init_device()" % self.get_name())
        self.set_state(PyTango.DevState.OFF)
        self.get_device_properties(self.get_device_class())
        
        self.configure = True
        self.serial = serial.Serial()
        
        self.serial.baudrate = self.baudrate
        self.serial.port = self.port
        
        if flagDebugIO:
            print("PhytronMcc2Ctrl.init_device: port is %s " % self.port)
            print("PhytronMcc2Ctrl.init_device: baudrate is %s " % self.baudrate)
            
        self.bytesize = 8
        self.serial.bytesize = self.bytesize
        
        self.parity = PhytronMcc2Ctrl.PARITIES[0]
        self.current_parity = self.parity
        self.serial.parity = serial.PARITY_NONE

        self.stopbits = 1
        self.serial.stopbits = self.stopbits

        self.timeout = 0
        self.serial.timeout = self.timeout
        
        self.flowcontrol = PhytronMcc2Ctrl.FLOWCONTROL[0]
        self.current_flowcontrol = self.flowcontrol
        self.serial.xonxoff = 0
        self.serial.rtscts = 0

        self.terminator = PhytronMcc2Ctrl.TERMINATOR[0]
        self.terminatorchar = chr(3)    # end of text PhytronMcc2Ctrl.TERMINATORCHAR[0]
        
        # open serial port
        self.open()

#------------------------------------------------------------------
#   Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.info_stream("In %s::always_excuted_hook()" % self.get_name())



#==================================================================
#
#   PhytronMcc2Ctrl read/write attribute methods
#
#==================================================================
    def read_attr_hardware(self,data):
        self.info_stream("In %s::read_attr_hardware()" % self.get_name())


    def read_port(self, attr):
        self.info_stream("In %s::read_port()" % self.get_name())

        #   Add your own code here
        attr_Port_read = self.serial.port
        attr.set_value(attr_Port_read)


    def write_port(self, attr):
        self.info_stream("In %s::write_port()" % self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s" % str(data))

        #   Add your own code here
        self.port = data[0]
        self.configure = True


    def is_port_allowed(self, req_type):
            #   End of Generated Code
            #   Re-Start of Generated Code
        return True


    def read_baudrate(self, attr):
        self.info_stream("In %s::read_baudrate()" % self.get_name())

        #   Add your own code here

        attr_baudrate_read = self.serial.baudrate
        attr.set_value(attr_baudrate_read)


    def write_baudrate(self, attr):
        self.info_stream("In %s::write_baudrate()" % self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s" % str(data))
        #   Add your own code here
        self.baudrate = data[0]
        self.configure = True

#---- Baudrate attribute State Machine -----------------
    def is_baudrate_allowed(self, req_type):
            #   End of Generated Code
            #   Re-Start of Generated Code
        return True


#------------------------------------------------------------------
#   read DataBits attribute
#------------------------------------------------------------------
    def read_DataBits(self, attr):
        self.info_stream("In %s::read_DataBits()" % self.get_name())

        #   Add your own code here

        attr_DataBits_read = self.serial.bytesize
        attr.set_value(attr_DataBits_read)


#------------------------------------------------------------------
#   write DataBits attribute
#------------------------------------------------------------------
    def write_DataBits(self, attr):
        self.info_stream("In %s::write_DataBits()" % self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s" % str(data))

        #   Add your own code here
        self.bytesize = data[0]
        self.configure = True

#---- DataBits attribute State Machine -----------------
    def is_DataBits_allowed(self, req_type):
            #   End of Generated Code
            #   Re-Start of Generated Code
        return True


#------------------------------------------------------------------
#   read StopBits attribute
#------------------------------------------------------------------
    def read_StopBits(self, attr):
        self.info_stream("In %s::read_StopBits()" % self.get_name())

        #   Add your own code here

        attr_StopBits_read = self.serial.stopbits
        attr.set_value(attr_StopBits_read)


#------------------------------------------------------------------
#   write StopBits attribute
#------------------------------------------------------------------
    def write_StopBits(self, attr):
        self.info_stream("In %s::write_StopBits()" % self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s" % str(data))

        #   Add your own code here
        self.stopbits = data[0]
        self.configure = True

#---- StopBits attribute State Machine -----------------
    def is_StopBits_allowed(self, req_type):
            #   End of Generated Code
            #   Re-Start of Generated Code
        return True


#------------------------------------------------------------------
#   read Terminator attribute
#------------------------------------------------------------------
    def read_Terminator(self, attr):
        self.info_stream("In %s::read_Terminator()" % self.get_name())

        #   Add your own code here

        attr_Terminator_read = self.terminator
        attr.set_value(attr_Terminator_read)


#------------------------------------------------------------------
#   write Terminator attribute
#------------------------------------------------------------------
    def write_Terminator(self, attr):
        self.info_stream("In %s::write_Terminator()" % self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s" % str(data))
        
        #   Add your own code here
        
        data[0] = data[0].upper()
        if data[0] in PhytronMcc2Ctrl.TERMINATOR:
            self.terminator = data[0]
            self.terminatorchar = PhytronMcc2Ctrl.TERMINATORCHAR[PhytronMcc2Ctrl.TERMINATOR.index(data[0])]
        else: 
            msg = "Allowed terminator values are "+", ".join(PhytronMcc2Ctrl.TERMINATOR)
            PyTango.Except.throw_exception("PhytronMcc2Ctrl_write_Terminator", msg, "write_Terminator()")


#---- Terminator attribute State Machine -----------------
    def is_Terminator_allowed(self, req_type):
            #   End of Generated Code
            #   Re-Start of Generated Code
        return True


#------------------------------------------------------------------
#   read FlowControl attribute
#------------------------------------------------------------------
    def read_FlowControl(self, attr):
        self.info_stream("In %s::read_FlowControl()" % self.get_name())

        #   Add your own code here

        attr_FlowControl_read = self.current_flowcontrol
        attr.set_value(attr_FlowControl_read)


#------------------------------------------------------------------
#   write FlowControl attribute
#------------------------------------------------------------------
    def write_FlowControl(self, attr):
        self.info_stream("In %s::write_FlowControl()" % self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s" % str(data))

        #   Add your own code here
        data[0] = data[0].lower()
        if data[0] in PhytronMcc2Ctrl.FLOWCONTROL:
            self.flowcontrol = data[0]
            self.configure = True   
        else:
            PyTango.Except.throw_exception("PhytronMcc2Ctrl_write_FlowControl", "Allowed flow control values are none, software, hardware and sw/hw", "write_FlowControl()")



#---- FlowControl attribute State Machine -----------------
    def is_FlowControl_allowed(self, req_type):
            #   End of Generated Code
            #   Re-Start of Generated Code
        return True


#------------------------------------------------------------------
#   read Timeout attribute
#------------------------------------------------------------------
    def read_Timeout(self, attr):
        self.info_stream("In %s::read_Timeout()" % self.get_name())

        #   Add your own code here

        attr_Timeout_read = int(self.serial.timeout * 1000)
        attr.set_value(attr_Timeout_read)


#------------------------------------------------------------------
#   write Timeout attribute
#------------------------------------------------------------------
    def write_Timeout(self, attr):
        self.info_stream("In %s::write_Timeout()" % self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s" % str(data))

        #   Add your own code here
        if data[0] == 0:
            self.timeout = 0
        else:
            self.timeout = float(data[0])/1000
        self.configure = True

#---- Timeout attribute State Machine -----------------
    def is_Timeout_allowed(self, req_type):
            #   End of Generated Code
            #   Re-Start of Generated Code
        return True


#------------------------------------------------------------------
#   read Parity attribute
#------------------------------------------------------------------
    def read_Parity(self, attr):
        self.info_stream("In %s::read_Parity()" % self.get_name())

        #   Add your own code here

        attr_Parity_read = self.current_parity
        attr.set_value(attr_Parity_read)


#------------------------------------------------------------------
#   write Parity attribute
#------------------------------------------------------------------
    def write_Parity(self, attr):
        self.info_stream("In %s::write_Parity()" % self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s" % str(data))

        #   Add your own code here
        data[0] = data[0].lower()
        if data[0] in PhytronMcc2Ctrl.PARITIES:
            self.parity = data[0]
            self.configure = True
        else:
            PyTango.Except.throw_exception("PhytronMcc2Ctrl_write_Parity", "Allowed parity values are none, odd, even", "write_Parity()")


#---- Parity attribute State Machine -----------------
    def is_Parity_allowed(self, req_type):
            #   End of Generated Code
            #   Re-Start of Generated Code
        return True


#------------------------------------------------------------------
#   read InputBuffer attribute
#------------------------------------------------------------------
    def read_InputBuffer(self, attr):
        self.info_stream("In %s::read_InputBuffer()" % self.get_name())

        #   Add your own code here
        try:
            attr_InputBuffer_read = self.serial.inWaiting()
            attr.set_value(attr_InputBuffer_read)
        except:
            pass


#---- InputBuffer attribute State Machine -----------------
    def is_InputBuffer_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True



#==================================================================
#
#   PhytronMcc2Ctrl command methods
#
#==================================================================

    def open(self):
        self.info_stream("In %s::Open()" % self.get_name())
        #   Add your own code here

        # configure port
        if self.configure:
            self.serial.baudrate = self.baudrate
            self.serial.port = self.port
            self.serial.bytesize = self.bytesize
            self.serial.stopbits = self.stopbits

            self.serial.timeout = self.timeout
            self.current_flowcontrol = self.flowcontrol

            if self.current_flowcontrol == "none":
                self.serial.xonxoff = 0
                self.serial.rtscts = 0
            elif self.current_flowcontrol == "software":
                self.serial.xonxoff = 1
                self.serial.rtscts = 0
            elif self.current_flowcontrol == "hardware":
                self.serial.xonxoff = 0
                self.serial.rtscts = 1
            elif self.current_flowcontrol == "sw/hw":
                self.serial.xonxoff = 1
                self.serial.rtscts = 1

            self.current_parity = self.parity               
            if self.current_parity == PhytronMcc2Ctrl.PARITIES[0]:
                self.serial.parity = serial.PARITY_NONE
            elif self.current_parity == PhytronMcc2Ctrl.PARITIES[1]:
                self.serial.parity = serial.PARITY_ODD
            elif self.current_parity == PhytronMcc2Ctrl.PARITIES[1]:
                self.serial.parity = serial.PARITY_EVEN

        try:
            self.serial.open()
            self.set_state(PyTango.DevState.ON)
            self.configure = False
        except:
            print("PhytronMcc2Ctrl.Open: failed to open %s " % self.port)
            sys.exit(255)
        
        if flagDebugIO:
            print("PhytronMcc2Ctrl.Open: connected to %s " % self.port)


    def is_open_allowed(self):
        if self.get_state() in [PyTango.DevState.ON,
                                PyTango.DevState.FAULT]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def close(self):
        self.info_stream("In %s::close()" % self.get_name())
        #   Add your own code here
        try:
            self.serial.close()
            self.set_state(PyTango.DevState.OFF)
        except:
            pass


    def is_close_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def flush_input(self):
        self.info_stream("In %s::flush_input()" % self.get_name())
        #   Add your own code here
        try:
            self.serial.flush_input()
        except:
            pass


    def is_flush_input_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def flush_output(self):
        self.info_stream("In %s::flush_output()" % self.get_name())
        #   Add your own code here
        try:
            self.serial.flush_output()
        except:
            pass


    def is_flush_output_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def write_read(self, cmd):
        self.serial.write(cmd.encode())
        self.serial.flush()
        # 20ms Warten
        time.sleep(0.02)    
        argout =  []
        s=''
        s = self.serial.readline()
        self.debug_stream(s)
        b = array.array('B', s)
        argout = b.tolist()
        return argout
        
    
    def write(self, cmd):
        self.info_stream("In %s::write()" % self.get_name())
        self.serial.write(cmd.encode())
        

    def is_write_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True
    
    
    def read(self, argin):
        self.info_stream("In %s::read()" % self.get_name())
        #   Add your own code here
        argout =  []
        s = self.serial.read(argin)
        self.debug_stream(s)
        b = array.array('B', s)
        argout = b.tolist()
        return argout


    def is_read_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


    def read_line(self):
        self.info_stream("In %s::read_line()" % self.get_name())
        #   Add your own code here
        argout =  []
        s = self.serial.readline(eol=self.terminatorchar)
        self.debug_stream(s)
        b = array.array('B', s)
        argout = b.tolist()
        return argout


    def is_read_line_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True
        

    def read_until(self,c):
        self.info_stream("In %s::read_until()" % self.get_name())
        #   Add your own code here
        argout =  []
        s = self.serial.read_until(c)
        self.debug_stream(s)
        b = array.array('B', s)
        argout = b.tolist()
        return argout


    def is_read_until_allowed(self):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.OFF]:
            #   End of Generated Code
            #   Re-Start of Generated Code
            return False
        return True


#==================================================================
#
#   PhytronMcc2CtrlClass class definition
#
#==================================================================
class PhytronMcc2CtrlClass(PyTango.DeviceClass):

    #   Class Properties
    class_property_list = {
        }


    #   Device Properties
    device_property_list = {
        'port':
            [PyTango.DevString,
            "COM Port of the device",
            ["none"] ],
        'baudrate':
            [PyTango.DevULong,
            "Baudrate of the COM port",
            [0]],

        }


    #   Command definitions
    cmd_list = {
        'open':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'close':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'flush_input':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'flush_output':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        
        
        'write':
            [[PyTango.DevString, ""],
            [PyTango.DevVoid, ""]],
        'read':
            [[PyTango.DevUShort, "Characters to read"],
            [PyTango.DevVarCharArray, "Characters readed"]],
        'read_line':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVarCharArray, "Characters readed"]],
        
    # added by Dirk
        'write_read':
            [[PyTango.DevString, ""],
            [PyTango.DevVarCharArray, "Characters readed"]],
            
        'read_until':
            [[PyTango.DevUChar, "end char"],
            [PyTango.DevVarCharArray, "Characters readed"]],            
        }


    #   Attribute definitions
    attr_list = {
        'Port':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'Memorized':"true",
            } ],
        'baudrate':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"Baudrate",
                'Memorized':"true",
            } ],
        'DataBits':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"DataBits",
                'max value':8,
                'min value':5,
                'Memorized':"true",
            } ],
        'StopBits':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"StopBits",
                'max value':2,
                'min value':1,
                'description':"1\n2\n",
                'Memorized':"true",
            } ],
        'Terminator':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description':"CR\nLF\nCR/LF\nNONE",
                'Memorized':"true",
            } ],
        'FlowControl':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"FlowControl",
                'description':"none\nhardware\nsoftware",
                'Memorized':"true",
            } ],
        'Timeout':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"Timeout",
                'min value':0,
                'description':"timeout=None            #wait forever\ntimeout=0               #non-blocking mode (return immediately on read)\ntimeout=x               #set timeout to x miliseconds (float allowed)",
                'Memorized':"true",
            } ],
        'Parity':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description':"none\nodd\neven",
                'Memorized':"true",
            } ],
        'InputBuffer':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ]],
        }


#==================================================================
#
#   PhytronMcc2Ctrl device server main method
#
#==================================================================
def main(*args):
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(PhytronMcc2CtrlClass, PhytronMcc2Ctrl,'PhytronMcc2Ctrl')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()
    except PyTango.DevFailed, e:
        print '-------> Received a DevFailed exception:',e
    except Exception, e:
        pass

#==================================================================
#
# PhytronMcc2Ctrl main call
#
#==================================================================

if __name__ == '__main__':
    main()
